---
# This script will demonstrate how to analyze the Soapberry data collected as 
# part of the LongTerm Ecological Monitoring Initiative
#
# Only one study area at time can only be analyzed with this script. 
#
# This was programmed by Carl James Schwarz, Statistics and Actuarial Science, SFU
# cschwarz@stat.sfu.ca
#
# 2022-11-20 Revised edition 
#    - changed to using Quarto to integrate the MSWord and R code together into one document
# 2017-02-28 First Edition

# Summary of Protocol
#   We count the number of berries produced on the exact same stems 
#   of soapberry bushes each year to give an index of soapberry production. 
#   No attempt to measure the total biomass production of soapberries per hectare.
#
#   Choose an area rich in soapberries is located for permanent monitoring. 
#   Choose 10 robust plants. Mark 2 branches on each plant for sampling.
#   The number of berries on each branch is recorded.
#   The branch diameter (mm) is also recorded
#
#   A sample of 25-50 ripe berries is selected and measured for average mass.
#
title: "`r paste0('Soap Berry - LTEM - ',params$STUDY_AREA_NAME)`"
date: today
date-format: YYYY-MM-DD
execute: 
  error: true
format: 
  html:
    toc: true
    number-sections: true
    self-contained: true
  pdf:
    toc: true
    number-sections: true
  docx:
    toc: true
    number-sections: true

params:
  STUDY_AREA_NAME: "Eskers"

---

```{r}
#| echo: false
#| warning: false
#| message: false
#| include: false

# set a default action of error:true to let all the chunks run


# load libraries
library(car)       # for testing for autocorrelation (2 libraries needed - see dwtest)
library(flextable) # for tables that look nice
library(ggfortify) # for residual and other diagnostic plot
library(ggplot2)   # for plotting
library(insight)   # for formatting p-values
library(lmtest)    # for testing for autocorrelation
library(lubridate) # date conversions
library(plyr)      # for group processing
library(readxl)    # for opening the Excel spreadsheets and reading off them
library(reshape2)  # for melting and casting
library(lmerTest)  # for the linear mixed modelling
library(sf)        # for extracting the LTEM data
library(stringr)   # string handling (like case conversion)

# Load some common functions
source("../2022-CommonFiles/common.functions.R")
source("../2022-CommonFiles/read.LTEM.R")
```


# Summary of Soap Berry LTEM protocol

## Basic protocol

Areas rich in soapberries is located for permanent monitoring. 
In each area, 10  robust bushes are chosen, and two stems on each 
plant are chosen for sampling. The stems and bushes are marked with 
permanent tags so that they can be revisited each year.

There are three measures taken in this protocol.

-	Berry count. The number of berries produced on the stem is 
recorded as an index of soapberry production. 
-	Stem diameter. The diameter (in millimeters) 
of the stem near its base is measured. 
-	Mean berry weight. A collection of 25-50 ripe red berries is 
obtained in August and weighed so the average wet weight of 
a single berry from each area is obtained. 

If the tagged stem has died (or is damaged or the tag on the stem has “disappeared”), 
a new stem is chosen. This may be from a new bush or the same bush. 
If the stem has been browsed, then no count is conducted on this stem this year.

If the tagged bush has died (or the tags on all of the stems have “disappeared”), 
a new bush is selected for subsequent monitoring.

## Cautions about the protocol.

### Don’t use 0 to indicate a missing value.

If a branch is present but the berries cannot be counted (e.g. browsed), 
a standardized codes should be entered into the data base. 
The berry count should be entered as MISSING rather than as zero.

### Codes for stem and bushes.

The Current field uses a plantxx-stemxx notation (e.g. plant1-stem1). 
If a bush dies and is replaced by a new bush, a different “plant” 
number should be used. Similarly if a stem is replaced on the same plant, 
use a different stem number (but linked to the same bush). 
If a new stem on new bush is used, both the plant (bush) and stem number 
should be new. 
Do NOT reuse bush numbers on different bushed; do not reuse stem numbers on the same bush.

## Database structure

The relevant fields from the database are:

-	Study Area Name. The name of the study area.
-	Sample Station Label. The bush/stem label.
-	Date. The date the data was collected. The Year is extracted from this date.
-	Berry Count. The number of soap berries on this stem. 
If the stem is browsed (or damaged) a missing value should be entered here and not the value of 0.
-	Stem Diameter. The diameter (mm) of the stem.
-	Average Weight. The average weight of a sample of berries is collected. 
Notice that there is only ONE mean weight found per year and so this value  
is replicated on every stem line of the sheet. The sample size used to determine the weight is in a separate column.

# Reading and checking the data

```{r}
#| echo: false
#| warning: false
#| message: false
#| include: false
#| 
# Get the data base information and any corrections here
berry.extract <- read.LTEM.data(study.type="Berries",
                                 site.names=params$STUDY_AREA_NAME)


```

The database was examined for all record pertaining to the
`r params$STUDY_AREA_NAME`. The following surveys were found:

```{r}
#| echo: false
cat("Surveys with the data \n")
berry.extract$projects[,c("SPI_PROJECT_ID","SURVEY_ID","START_DATE","STUDY_AREA_NAME")]
```


```{r}
#| echo: false

soop.df <- berry.extract$user.data
```

The following data editing was performed

## Variables names corrected for *R*

Variable names in *R* must start with a letter and contain letters or numbers or underscores.
Blanks in variable names are not normally allowed, nor are special characters such as %.
These are normally replaced by periods (".") in the variable name.

```{r}
#| echo: false

#------------ Data Editing -----------
# fix up variable names in the data.frame.
# Variable names in R must start with a letter and contain letters or number or _. 
# Blanks in variable names are not normally allowed. Blanks will be replaced by . (period)
cat("\nOriginal variable names in data frame\n")
names(soop.df)

names(soop.df) <- make.names(names(soop.df))

cat("\nCorrected variable names of data frame\n")
names(soop.df)
```

## Check the number of records by year.

Check that the number of observations by year seems reasonable:

```{r}
#| echo: false
#| 
cat("\n\nThe number of records by year are \n")
xtabs(~STUDY_AREA_NAME+Year, data=soop.df, exclude=NULL, na.action=na.pass)  # check the date formats. 
```

## Checking Study Area Name

The Study Area Name should be recorded consistently across years, otherwise 
it may indicate that different sites are being studies. The study area name
is converted to Title Case.

The list of Study Area Names by year in the data is:

```{r}
#| echo=FALSE

# Check that the Study Area Name is the same across all years
# Look at the output from the xtabs() to see if there are multiple spellings 
# of the same STUDY_AREA_NAME.

# We will convert the STUDY_AREA_NAME to Proper Case.
soop.df$STUDY_AREA_NAME <- stringr::str_to_title(soop.df$STUDY_AREA_NAME)
xtabs(~STUDY_AREA_NAME+Year, data=soop.df, exclude=NULL, na.action=na.pass)

if(!all(grepl(params$STUDY_AREA_NAME, soop.df$STUDY_AREA_NAME, ignore.case=TRUE))){
  cat("*** ERROR *** STUDY_AREA_NAMEs are not consistent\n")
  cat("A tabulation of STUDY_AREA_NAMEs in datasets is \n")
  xtabs(~STUDY_AREA_NAME, data=soop.df, exclude=NULL, na.action=na.pass)
  cat("Requested study area was ", params$STUDY_AREA_NAME,  "\n")
  #knitr::knit_exit()
}

if(length(unique(soop.df$STUDY_AREA_NAME))>1){
   cat("*** ERROR *** More than one study area found \n")
   cat("\n\nThe number of records by year are \n")
   xtabs(~STUDY_AREA_NAME+Year, data=soop.df, exclude=NULL, na.action=na.pass)  # check the date formats. 
   #knitr::knit_exit()
   soop.df$STUDY_AREA_NAME <- "**MANUALLY SET**"
   xtabs(~STUDY_AREA_NAME+Year, data=soop.df, exclude=NULL, na.action=na.pass)  
}

```


## Checking species code

The species code should be the same across the years of the project.

```{r}
#| echo: false
# Check the Species code to make sure that all the same
# This isn't used anywhere in the analysis but is useful to know
xtabs(~SPECIES_CODE+Year, data=soop.df, exclude=NULL, na.action=na.pass)

if(length(unique(soop.df$SPECIES_CODE))>1){
   cat("*** WARNING *** More than one species name found \n")
   cat("\n\nThe number of records by species and year are \n")
   xtabs(~SPECIES_CODE+Year, data=soop.df, exclude=NULL, na.action=na.pass)  # check the date formats. 
   #stop()
}

```

## Check the plant/bush and stem/branch numbers 

The bush and stem numbers are also recorded.
Each bush/plant should be followed for several years in a row, and the label 
for the bush should not be replicated if the bush is replaced by a new bush.

This needs to be check in the tables below. For example, ensure that a "bush" or "stem" is not measured
for a few years, is not then measured, and then starts again -- this may be an indication that the plant
was replaced, but not relabeled (or a particular plant was not measured in a particular year)

```{r}
#| echo: false
#
# check the extraction
xtabs(~BUSH+Year, data=soop.df, exclude=NULL, na.action=na.pass)
xtabs(~STEM+Year, data=soop.df, exclude=NULL, na.action=na.pass)

# check to see if any BUSH number is stopped and then started
# Checking bush numbers
year.set <- sort(unique(soop.df$Year))
plyr::d_ply(soop.df, "BUSH", function(bush){
   # create capture history
   cap.hist <- rep(0,length(year.set))
   cap.hist[ match(bush$Year, year.set)] <- 1
   # look for internal 0's (e.g. 1 0 1) that indicates a stop measuring and then start over.
   # find the last 1 from the left and the first 1 from the right. If these don't match, a potential problem
   from.left   <- which.max(cap.hist)
   from.right  <- length(year.set)+1-which.max(rev(cap.hist))
   #browser()
   if(0==prod(cap.hist[from.left:from.right])){
      cat("Check bush/plant data below \n")
      bush
   }
})

# check to see if any STEM number is stopped and then started
# Checking bush numbers
year.set <- sort(unique(soop.df$Year))
plyr::d_ply(soop.df, "STEM", function(stem){
   # create capture history
   cap.hist <- rep(0,length(year.set))
   cap.hist[ match(stem$Year, year.set)] <- 1
   # look for internal 0's (e.g. 1 0 1) that indicates a stop measuring and then start over.
   # find the first 1 from the left and the first 1 from the right and see if any internal zero?
   from.left   <- which.max(cap.hist)
   from.right  <- length(year.set)+1-which.max(rev(cap.hist))
   #browser()
   if(0==prod(cap.hist[from.left:from.right])){
      cat("Check stem/branch data below \n")
      stem
   }
})

```

<!-- ## Extract sample size and the mean berry weight -->

<!-- ```{r} -->
<!-- #| echo: false -->

<!-- # The sample size for the berry weight is given in the N.for.average.berry.count field -->
<!-- # Note that even though this field is replicated for all observations, there is ONLY one -->
<!-- # measurement of weight taken for the entire year. -->
<!-- xtabs(~Year+N.for.average.berry.count, data=soop.df, exclude=NULL, na.action=na.pass) -->

<!-- # check the berry count. These need to be numeric -->
<!-- #xtabs(~Year+Berry.Count, data=soop.df, exclude=NULL, na.action=na.pass) -->

<!-- soop.df$Berry.Count.new<- as.numeric(soop.df$Berry.Count) -->
<!-- if(any(!is.na(soop.df$Berry.Count.new))){ -->
<!--    cat("Some berry counts appear to be missing or non-numeric\n") -->
<!--    select <- is.na(soop.df$Berry.Count.new) -->
<!--    soop.df[select, c("STUDY_AREA_NAME","Sample.station.label","Date","Berry.Count","Berry.Count.new")] -->
<!--    #stop() -->
<!-- } -->
<!-- #xtabs(~Year+Berry.Count, data=soop.df, exclude=NULL, na.action=na.pass) -->

<!-- ``` -->

## Check the comments

The comments recorded should be reviewed in case these indicate problems with the data,
For example, if the comment is "heavily browsed" make sure that the Berry.Count is recorded as NA and not as 0.

```{r}
#| echo: false

# check other comments. You may need to adjust the data to account for 
# problems in the data. 
# For example, if the comment is "heavily browsed" make sure that 
#   the Berry.Count is NA and not 0
#xtabs(~COMMENT+Berry.Count, data=soop.df, exclude=NULL, na.action=na.pass)
xtabs(~COMMENT     ,        data=soop.df, exclude=NULL, na.action=na.pass)
```

```{r}
#| echo: false

# Get the file prefix
file.prefix <- make.names(soop.df$STUDY_AREA_NAME[1])
file.prefix <- gsub(".", '-', file.prefix, fixed=TRUE) # convert . to 
if(!dir.exists("PLots"))dir.create("Plots")
file.prefix <- file.path("Plots", file.prefix)
```


# Single Site Analysis

Date for the `r params$STUDY_AREA_NAME` are available from `r min(soop.df$Year, na.rm=TRUE)` to 
`r max(soop.df$Year, na.rm=TRUE)`. 

This design has multiple transects that are repeated measured over time 
with multiple plots measured on each transect that are also repeated 
measured over time. 
Please refer to the Fitting Trends with Complex Study Designs document in the 
CommonFile directory for information on fitting trends with complex study designs. 

All analyses were done using the R (R Core Team, 2023)  analysis system. 
All plots are also saved as separate *png files for inclusion into other reports.


## Mean berry weight.

This measurement is taken at the site level and so there is one measurement 
available per site/year. Notice that this value is replicated multiple times in the 
database for each individual stem. 
These are NOT real replicated readings but only an artifact of the database 
so some care is needed to extract only a single value per individual stem on a site/year.

A simple linear regression is used to look for changes over time using the model (in standard notation)
$$\mathit{MBW} \sim \mathit{Year}$$
where 

- $\mathit{MBW}$ is the mean berry weight and
- $\mathit{Year}$ is the calendar year over time. 

This model can be fit using the *lm()* function in R. 

```{r}
#| echo: false
#| 
#----------------------------------------------------------------------------------------
#  Analysis of the mean weight of berries.

# Look at mean weight of berries over time
# Remember there is only one value per year so we need to extract from the database.
# We take the mean for each year. We also take the SD. If this is >0 then the
# data in the database is not consistent

soop.df$Mean.Berry.Weight..gm. <- as.numeric(soop.df$Mean.Berry.Weight..gm.)

berry.weight <- plyr::ddply(soop.df, c("STUDY_AREA_NAME","Year"), plyr::summarize, 
                            Mean.weight   =mean(Mean.Berry.Weight..gm., na.rm=TRUE),
                            Mean.weight.sd=sd(  Mean.Berry.Weight..gm., na.rm=TRUE)
                            #,N.Mean.weight =mean(N.for.average.berry.count, na.rm=TRUE)
                            )

cat("Listing of SD of Mean.Berry weights by study area and year\n")
berry.weight

# check to see if any of the Mean.weight.sd >0 indicating that the data is not consistent on the sheets
if(any(berry.weight$Mean.weight.sd >0, na.rm=TRUE)){
  cat("*** ERROR *** Multiple measures on mean berry weight were given for a year\n")
  berry.weight[ berry.weight$Mean.weight.sd >0,]
  #knitr::knit_exit()
}

# listing of data
#berry.weight

if(sum(!is.na(berry.weight$Mean.weight))<3){
   cat("*** Error - inadequate numbers of mean weight of berries \n")
   berry.weight
   #knitr::knit_exit()
}


# Fit a linear trend through the data and check for evidence of a trend.
weight.fit <- lm(Mean.weight ~ Year, data=berry.weight)

cat("\n\n")
anova(weight.fit)
cat("\n\n")
summary(weight.fit)

weight.fit.pvalue <- anova(weight.fit)[1,"Pr(>F)"]
weight.fit.slope  <- coef(weight.fit)[2]
weight.fit.slope.se <- sqrt(diag(vcov(weight.fit)))[2]
```

@fig-weight-trend shows a summary plot, along with estimates of the slope, its standard error,
and the p-value of the hypothesis of no trend. With 
`r length(unique(berry.weight$Year))` years of data, 
the estimated slope is 
`r round(weight.fit.slope,3)` 
(SE `r round(weight.fit.slope.se,3)`) g/year 
(`r insight::format_p(weight.fit.pvalue)`).


```{r}
#| echo: false
#| fig-cap: "Trend in mean berry weight"
#| label: fig-weight-trend
#| warning: false
#| message: false

# extract a table of slopes 
weight.slopes <- data.frame(
  STUDY_AREA_NAME=berry.weight$STUDY_AREA_NAME[1],
  slope    = weight.fit.slope,
  slope.se = weight.fit.slope.se,
  p.value  = weight.fit.pvalue, 
  r2       = summary(weight.fit)$r.squared,
  stringsAsFactors=FALSE)
#weight.slopes

# Plot with trend line with a separate plot for each StudyArea
weight.plot.summary <- ggplot2::ggplot(data=berry.weight,
                                    aes(x=Year, y=Mean.weight))+
   ggtitle("Mean berry weight ")+
   ylab("Mean weight (g)")+
   geom_point(size=3)+
   geom_smooth(method="lm", se=FALSE)+
   facet_wrap(~STUDY_AREA_NAME, ncol=2, scales="free" )+
   scale_x_continuous(breaks=integer_breaks())+
   geom_text(data=weight.slopes, aes(x=min(berry.weight$Year, na.rm=TRUE), y=max(berry.weight$Mean.weight, na.rm=TRUE)), 
             label=paste("Slope : ",round(weight.slopes$slope,3), 
                         " ( SE "  ,round(weight.slopes$slope.se,3),")",
                         insight::format_p(weight.slopes$p.value)),
                         hjust="left")
weight.plot.summary
ggsave(plot=weight.plot.summary, 
       file=paste(file.prefix,'-weight-plot-summary.png',sep=""),
       h=6, w=6, units="in", dpi=300)
```




```{r}
#| echo: false
#| fig-cap: "Model fit diagnostic plots from trend in mean berry weight"
#| label: fig-weight-resid
#| warning: false
#| message: false
#| error: true

# Look at the residual plots and save them to the directory
weight.diag.plot <- autoplot(weight.fit)  # residual and other diagnostic plots
show(weight.diag.plot)
ggsave(#plot=weight.diag.plot, #bug in ggsave with ggmultiplots that you don't specify object
       file=paste(file.prefix,"-weight-residual-plot.png",sep=""),
       h=6, w=6, units="in", dpi=300)
```

Residual plots are presented in (@fig-weight-resid).
With only `r length(unique(berry.weight$Year))` years of data, 
the plots are not very informative. In the upper left corner is a plot of residuals vs. 
the fitted values. A good plot will show a random scatter around 0. 
Any large deviations from 0 should be investigated as potential outliers. 
In the upper right is a normal probability plot. Points should be close to the dashed reference line. 
Fortunately, the analysis is fairly robust against non-normality so only extreme departures are worrisome. 
The bottom left plot examine the assumption that the variation about the line is constant over the line. 
You would expect to see a constant band of points. 
Finally the bottom right plot is a leverage plot – this is not useful for this simple model and can be ignored. 

It will also be possible to covariates such as mean winter temperature 
or degree days in the year to try and explain some of the variation over time 
using a multiple regression. With only `r length(unique(berry.weight$Year))`
years of data available, this not sensible.


```{r}
#| echo: false
#| warning: false
#| message: false
#| error: true

# check for autocorrelation
weight.dwres1 <- car::durbinWatsonTest(weight.fit)
#weight.dwres1
weight.dwres2 <- lmtest::dwtest(weight.fit)
#weight.dwres2
```

Whenever an analysis of a trend over time is conducted, the analysis 
should test and adjust for autocorrelation. 
Autocorrelation usually isn’t a problem (and likely cannot be detected) unless you have 10+ years of data. 
The test for autocorrelation commonly used is the Durbin-Watson test and we find
(`r insight::format_p(weight.dwres1$p)` for the test of no autocorrelation.






If the number of berries used to compute the average is quite different over years, a weighted analysis (number of berries used in computing the mean) may be needed. 


```{r}
#| echo: false
#----------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------
```

##  Stem Diameter. 
This measurement is taken at the stem level and so there is one value per stem/bush/year. 
The same stem is repeatedly measured over time, but stems may leave the protocol (damaged or dead) 
or be added to the protocol (replacement stem) over time. 
All of the models below automatically will account for stems that are 
removed or added as long as each stem has a unique label within a site.

A linear mixed model will be used to look for changes over time 
to account for the repeated measurements over time of each branch on the same plant:
$$StemD \sim \mathit{Year} + \mathit{YearF}(R) + \mathit{BushF}(R)+ \mathit{StemF}(R)$$
 
where 

- $StemD$ is the measured stem diameter, 
- $\mathit{Year}$ is the term representing the trend over time; 
- $\mathit{YearF(R)}$, $\mathit{BushF}(R)$, and $\mathit{StemF}(R)$ are the random effects of year-specific factors, 
bushes and stems respectively. 
These random effects are needed to account for the repeated measurement of the 
same stem (the $\mathit{StemF}(R)$) term; 
multiple stems measured from the same plant ($\mathit{BushF}(R)$) term; 
and year-specific factors (also known as process error, $\mathit{YearF(R)}$). 
The process error term is distinguished from the simple trend term $\mathit{Year}$. 

For example, all of the stems on the same bush may have 
related diameters because they are all similar aged. 
Similarly, the repeated measurements on the same stem over time will be related.

This model is fit using the *lmer()* function in the lmerTest package 
(Kuznetsova, et al. 2016) and a summary is shown in @fig-stemd-trend.

```{r}
#| echo: false
#| warning: false
#| message: false
#  Analysis of the stem diameter.
#  Each stem is measured on each bush in each year.
#  We need to account for the repeated measurements of each stem/bush combination over time
#  using a linear mixed models. 
#  We need to account for year process error. Essentially, you need to get one number
#  per year for the analysis (the mean), but we need to account for the repeated measurements

soop.df$BUSHF <- factor(soop.df$BUSH)
soop.df$STEMF <- factor(soop.df$STEM)
soop.df$YearF <- factor(soop.df$Year)  # This represents process error 

soop.df$Branch.Diameter..mm. <- as.numeric(soop.df$Branch.Diameter..mm.)

stem.diam <- soop.df[!is.na(soop.df$Branch.Diameter..mm.),]

# incase the fit fails  
stemd.fit.pvalue   <- NA
stemd.fit.slope    <- NA
stemd.fit.slope.se <- NA

# do the fit
stemd.fit <- lmerTest::lmer(Branch.Diameter..mm. ~ Year + (1|YearF) + (1|BUSHF) + (1|STEMF), data=stem.diam)

stemd.fit.pvalue <- anova(stemd.fit, ddfm="Kenward-Roger")[1,"Pr(>F)"]
stemd.fit.slope  <- fixef(stemd.fit)[2]
stemd.fit.slope.se <- sqrt(diag(vcov(stemd.fit)))[2]

cat("\n\n")
anova(stemd.fit, ddfm="Kenward-Roger")
cat("\n\n")
summary(stemd.fit)$coefficients

```

@fig-stemd-trend shows a summary plot, along with estimates of the slope, its standard error,
and the p-value of the hypothesis of no trend. With 
`r length(unique(berry.weight$Year))` years of data, 
the estimated slope is 
`r round(stemd.fit.slope,3)` 
(SE `r round(stemd.fit.slope.se,3)`) g/year 
(`r insight::format_p(stemd.fit.pvalue)`).

Note that because of the presence of process error, the effective 
sample for testing a trend is the number of YEARS and not the 
total number of observations, i.e. the three X’s essentially define the trend, 
while the other data points provide information about bush-to-bush variation 
and stem-to-stem variation, they provide little information on trend. 

```{r}
#| echo: false
#| fig-cap: "Trend in mean stem diameter. Points are jittered to reduce overplotting. The X indicate the observed mean of the data points in each year and deviations of the X from the trend line would represent (approximately) process error."
#| label: fig-stemd-trend
#| warning: false
#| message: false
#| 
# extract a table of statistics for each study area
stemd.slopes <- data.frame(
  STUDY_AREA_NAME = stem.diam$STUDY_AREA_NAME[1],
  slope           = fixef(  stemd.fit)["Year"],
  slope.se        = sqrt(diag(vcov(  stemd.fit)))[names(fixef(  stemd.fit))=="Year"],
  p.value         = summary(  stemd.fit)$coefficients[row.names(summary(  stemd.fit)$coefficients)=="Year"  ,"Pr(>|t|)"], 
  stringsAsFactors=FALSE)
#stemd.slopes

# compute the fitted values from the model
stemd.fitted <- data.frame(
                 STUDY_AREA_NAME=stem.diam$STUDY_AREA_NAME[1],
                 Year=seq(min(stem.diam$Year, na.rm=TRUE),max(stem.diam$Year, na.rm=TRUE), .1),
                 stringsAsFactors=FALSE)
stemd.fitted$pred.mean <- predict(stemd.fit, newdata=stemd.fitted, type="response", re.form=~0)
#head(stemd.fitted)


# Plot with trend line with a separate plot for each StudyArea
# We add in the observed mean for each year to look at autocorrrelation overtime
stemd.yearly.mean <- plyr::ddply(stem.diam, c("STUDY_AREA_NAME","Year"), plyr::summarize,
                                mean.stem=mean(Branch.Diameter..mm., na.rm=TRUE))
stemd.yearly.mean



stemd.plot.summary <- ggplot2::ggplot(data=soop.df,
                                    aes(x=Year, y=Branch.Diameter..mm.))+
   ggtitle("Stem Diameter ")+
   ylab("Stem diameter (mm)")+
   geom_point(size=1, aes(color=BUSH), position=position_dodge(w=.1))+
   geom_point(data=stemd.yearly.mean, aes(y=mean.stem), shape="X", size=4)+
   geom_line(data=stemd.fitted, aes(y=pred.mean))+
   facet_wrap(~STUDY_AREA_NAME, ncol=2, scales='free')+
   scale_x_continuous(breaks=integer_breaks())+
   geom_text(data=stemd.slopes, aes(x=min(soop.df$Year, na.rm=TRUE), y=max(soop.df$Branch.Diameter..mm., na.rm=TRUE)), 
             label=paste("Slope : ",round(stemd.slopes$slope,2), 
                         " ( SE "  ,round(stemd.slopes$slope.se,2),")",
                         insight::format_p(stemd.fit.pvalue)),
                         hjust="left")
stemd.plot.summary
ggsave(plot=stemd.plot.summary, 
       file=paste(file.prefix,'-stemd-plot-summary.png',sep=""),
       h=6, w=6, units="in", dpi=300)
```


```{r}
#| echo: false
#| label: tbl-stemd-vc
#| tbl-cap: "Estimated variance components for stem diameter"

temp <- as.data.frame(VarCorr(stemd.fit))
temp <- temp[,c("grp","sdcor")]
temp$grp <- gsub("F$","", temp$grp)

ftable <- flextable(temp)
ftable <- set_header_labels(ftable, values = list(grp="Source", sdcor="SD"))
ftable <- colformat_double(ftable, j=2, digits=3)
ftable
```

One of the outputs from this analysis is the relative size of the 
standard deviations in the points due to year-specific factor, bushes, stems within bushes, 
and residual (unknown) sources (@tbl-stemd-vc).



The stem-to-stem variation (within a bush) is comparable to the 
bush-to-bush variation and residual variation and all are much larger than year-specific effect (process error). 
This is not too surprising because it is hard to imagine 
that stem diameter could be readily influenced by year-specific factors (unlike, for example, berry counts).


```{r}
#| echo: false
#| fig-cap: "Model fit diagnostic plots from trend in stem diameter"
#| label: fig-stemd-resid
#| warning: false
#| message: false
#| error: true

# Look at the residual plots and save them to the directory
stemd.diag.plot <- sf.autoplot.lmer(  stemd.fit)  # residual and other diagnostic plots
plot(stemd.diag.plot)
ggsave(#plot=diag.plot, 
       file=paste(file.prefix,"-stemd-residual-plot.png",sep=""),
       h=6, w=6, units="in", dpi=300)

```

Residual plots are presented in (@fig-stemd-resid).
The upper two plots are interpreted in the same way as noted previously. 
There is some (very weak) evidence of a lack of fit for stems with larger diameters.
but it is not serious. Caterpillar plots attempt to show the distribution of the random effects. 
If the model fits well, you would expect the blue dots (the estimated random effect) to lie mostly 
in the $\pm 2$ standard deviation bands with no obvious outliers. 
There are no obvious outliers in the stem or bush random effects and there are too few years to say much.

As with the analysis of mean berry weight, covariates can also be added to the
model to explain some of the year-specific effects.

```{r}
#| echo: false
#| warning: false
#| message: false
#| error: true



#test for autocorrelation by finding the average residual for each year
stem.diam$resid <- stem.diam$Branch.Diameter..mm. - predict(stemd.fit, newdata=stemd.fitted, type="response", re.form=~0)
mean.resid <- plyr::ddply(stem.diam, "Year", summarize, mean.resid=mean(resid))
resid.fit <- lm( mean.resid ~ 1, data=mean.resid)
stemd.dwres1 <- car::durbinWatsonTest(resid.fit)
#dwres1
stemd.dwres2 <- lmtest::dwtest(resid.fit)
#dwres2
```


Whenever an analysis of a trend over time is conducted, the analysis will 
have to test and adjust for autocorrelation in the year-specific effect. 
This usually isn’t a problem unless there are 10+ years of data. 
Autocorrelation usually isn’t a problem (and likely cannot be detected) unless you have 10+ years of data. 
The test for autocorrelation commonly used is the Durbin-Watson test and we find
`r try(insight::format_p(stemd.dwres1$p, missing="p is Not avail"), silent=TRUE)` 
for the test of no autocorrelation.




```{r}
#| echo: false
#----------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------
```


## Berry Count.

This measurement is taken at the stem level and so there is one 
value per stem/plant/year. 
The same stem/plant is repeated measured over time. 
All of the models below automatically will account for branches that are 
removed or added as long as each stem has a unique label within a site.
The models for the berry count are similar to those from the stem diameter 
except that the counts may be somewhat smallish. 
The average count is about 5 or less, then a Poisson regression can, in theory, be used. 
However, if there are several random effects, then a Poisson mixed effects model 
is extremely difficult to fit. 
However, for larger counts, a linear mixed model on the log(counts+0.5) will work well 
and avoids many of the problems in dealing with generalized linear mixed models. 

A linear mixed model will be used to look for changes over time in the mean berry count 
to account for the repeated measurements over time of each branch on the same plant:
$$log(BerryCount+0.5) \sim \mathit{Year} + \mathit{YearF(R)} + \mathit{BushF}(R)+ Stem(R)$$
 
where 

- $BerryCount$ is the measured berry count on a stem, 
- $\mathit{Year}$ is the trend; 
- $\mathit{YearF}(R)$, $\mathit{BushF}(R)$, and $\mathit{StemF}(R)$ are the random effects of year-specific factors, 
bushes and stems respectively. 
These random effects are needed to account for the repeated measurement of the 
same stem (the $\mathit{StemF}(R)$) term; 
multiple stems measured from the same plant ($\mathit{BushF}(R)$) term; 
and year-specific factors (also known as process error, $\mathit{YearF(R)}$). 
The process error term is distinguished from the simple trend term $\mathit{Year}$. 

This model is fit using the *lmer()* function in the lmerTest package 
(Kuznetsova, et al. 2016) and a summary is shown in @fig-count-trend.

```{r}
#| echo: false
#| warning: false
#| message: false

#  Analysis of the berry counts
#  Each stem is measured on each bush in each year.
#  We need to account for the repeated measurements of each stem/bush combination over time
#  using a linear mixed models.
#  The counts are large enough that we can use a normal theory model on log(count+.5) rather than a Poisson regression.
#  We analyze on the log-scale to account for the increasing variation over time
#  We need to account for year process error. Essentially, you need to get one number
#  per year for the analysis (the mean), but we need to account for the repeated measurements

#range(soop.df$Berry.Count, na.rm=TRUE)

soop.df$BUSHF <- factor(soop.df$BUSH)
soop.df$STEMF <- factor(soop.df$STEM)
soop.df$YearF<- factor(soop.df$Year)  # This represents process error 

# remove missing values
soop.df$Berry.Count <- as.numeric(soop.df$Berry.Count)
count.df <- soop.df[ !is.na(soop.df$Berry.Count),]

# set this in case the fit does not work
count.fit.pvalue   <- NA
count.fit.slope    <- NA
count.fit.slope.se <- NA

count.fit <- lmerTest::lmer(log(Berry.Count+.5) ~ Year + (1|Year)+  (1|BUSHF) + (1|STEMF), data=count.df)

count.fit.pvalue <- anova(count.fit, ddfm="Kenward-Roger")[1,"Pr(>F)"]
count.fit.slope  <- fixef(count.fit)[2]
count.fit.slope.se <- sqrt(diag(vcov(count.fit)))[2]

cat("\n\n")
anova(count.fit, dfm="Kenward-Roger")
cat("\n\n")
summary(count.fit)$coefficients

```

With 
`r length(unique(berry.weight$Year))` years of data, 
the estimated slope on the logarithmic scale is 
`r round(count.fit.slope,3)` 
(SE `r round(count.fit.slope.se,3)`) g/year 
(`r insight::format_p(count.fit.pvalue)`).

Note that because of the presence of process error, the effective 
sample for testing a trend is the number of YEARS and not the 
total number of observations, i.e. the three X’s essentially define the trend, 
while the other data points provide information about bush-to-bush variation 
and stem-to-stem variation, they provide little information on trend. 

```{r}
#| echo: false
#| fig-cap: "Trend in log(berry count). The X indicates the mean of the counts for that year showing a small year-specific effect because they are not centered on the trend line."
#| label: fig-count-trend
#| warning: false
#| message: false
#| 
# extract a table of statistics for each study area
# extract a table of the slopes
count.slopes <- data.frame(
       STUDY_AREA_NAME = count.df$STUDY_AREA_NAME[1],
       slope           = fixef(count.fit)["Year"],
       slope.se        = summary(count.fit)$coefficients["Year","Pr(>|t|)"],
       p.value         = summary(count.fit)$coefficients[row.names(summary(count.fit)$coefficients)=="Year"  ,"Pr(>|t|)"], 
       #r2             = summary(count.fit)$r.squared,  # not defined for mixed effect models
       stringsAsFactors=FALSE)
#count.slopes

# Plot with trend line with a separate plot for each StudyArea
count.yearly.mean <- plyr::ddply(count.df, c("STUDY_AREA_NAME","Year"), plyr::summarize,
                                mean.count=mean(Berry.Count, na.rm=TRUE))
#count.yearly.mean

# compute the fitted values from the model
# The model was run on the log(average count), so we need to back transform
count.fitted <- data.frame(
                 STUDY_AREA_NAME=count.df$STUDY_AREA_NAME[1],
                 Year=seq(min(count.df$Year, na.rm=TRUE),max(count.df$Year, na.rm=TRUE), .1),
                 stringsAsFactors=FALSE)
count.fitted$pred.mean <- exp(predict(count.fit, newdata=count.fitted,type="response", re.form=~0))
#head(count.fitted)



# make some summary plots
count.plot.summary <- ggplot2::ggplot(data=count.df,
                                    aes(x=Year, y=Berry.Count))+
   ggtitle("Berry Count ")+
   ylab("Berry Count")+
   geom_point(size=1, aes(color=BUSH), position=position_dodge(w=.1))+
   geom_point(data=count.yearly.mean, aes(y=mean.count), shape="X", size=4)+
   geom_line(data=count.fitted, aes(y=pred.mean))+
   facet_wrap(~STUDY_AREA_NAME, ncol=2, scales='free')+
   scale_x_continuous(breaks=integer_breaks())+
   geom_text(data=count.slopes, aes(x=min(soop.df$Year,na.rm=TRUE), y=max(soop.df$Berry.Count,na.rm=TRUE)), 
             label=paste("Slope (on log scale) : ",round(count.slopes$slope,2), 
                         " ( SE "  ,round(count.fit.slope.se,2),")",
                         insight::format_p(count.fit.pvalue)),
                         hjust="left")
count.plot.summary
ggsave(plot=count.plot.summary, 
       file=paste(file.prefix,'-count-plot-summary.png',sep=""),
       h=6, w=6, units="in", dpi=300)
```


```{r}
#| echo: false
#| label: tbl-count-vc
#| tbl-cap: "Estimated variance components for berry counts"

temp <- as.data.frame(VarCorr(count.fit))
temp <- temp[,c("grp","sdcor")]
temp$grp <- gsub("F$","", temp$grp)

ftable <- flextable(temp)
ftable <- set_header_labels(ftable, values = list(grp="Source", sdcor="SD"))
ftable <- colformat_double(ftable, j=2, digits=3)
ftable
```

One of the outputs from this analysis is the relative size of the 
standard deviations in the points due to year-specific factor, bushes, stems within bushes, 
and residual (unknown) sources (@tbl-count-vc).



The stem-to-stem variation (within a bush) is comparable to the 
bush-to-bush variation and residual variation and all are much 
larger than year-specific effect (process error). 
This is not too surprising because it is hard to imagine 
that stem diameter could be readily influenced by year-specific factors (unlike, for example, berry counts).


```{r}
#| echo: false
#| fig-cap: "Model fit diagnostic plots from trend in berry counts"
#| label: fig-count-resid
#| warning: false
#| message: false
#| error: true

# Look at the residual plots and save them to the directory
count.diag.plot <- sf.autoplot.lmer(  count.fit)  # residual and other diagnostic plots
plot(count.diag.plot)
ggsave(#plot=diag.plot, 
       file=paste(file.prefix,"-count-residual-plot.png",sep=""),
       h=6, w=6, units="in", dpi=300)

```

Residual plots are presented in (@fig-count-resid).
The upper two plots are interpreted in the same way as noted previously. 
There is some (very weak) evidence of a lack of fit for stems with larger diameters.
but it is not serious. Caterpillar plots attempt to show the distribution of the random effects. 
If the model fits well, you would expect the blue dots (the estimated random effect) to lie mostly 
in the $\pm 2$ standard deviation bands with no obvious outliers. 
There are no obvious outliers in the stem or bush random effects and there are too few years to say much.

As with the analysis of mean berry weight, covariates can also be added to the
model to explain some of the year-specific effects.

```{r}
#| echo: false
#| warning: false
#| message: false
#| error: true

#test for autocorrelation by finding the average residual for each year
# check for autocorrelation 
count.df$resid <- log(count.df$Berry.Count+.5) - predict(count.fit, newdata=count.df, re.form=~0)
mean.resid <- plyr::ddply(count.df, "Year", summarize, mean.resid=mean(resid))
resid.fit <- lm( mean.resid ~ 1, data=mean.resid)
count.dwres1 <- car::durbinWatsonTest(resid.fit)
#dwres1
count.dwres2 <- lmtest::dwtest(resid.fit)
#dwres2
```


Whenever an analysis of a trend over time is conducted, the analysis will 
have to test and adjust for autocorrelation in the year-specific effect. 
This usually isn’t a problem unless there are 10+ years of data. 
Autocorrelation usually isn’t a problem (and likely cannot be detected) unless you have 10+ years of data. 
The test for autocorrelation commonly used is the Durbin-Watson test and we find
`r try(insight::format_p(count.dwres1$p, missing="p is Not avail"),silent=TRUE)` 
for the test of no autocorrelation.

# Power analysis

A power/sample size analysis was conducted to determine the number of years of sampling needed to detect
changes over time. The steps in the power/sample size analysis are:

- Compute a single number summarizing the response at this site in each year. The mean berry weight is already a single number per year.
The mean stem diameter and mean berry count will be computed as averages of averages over the various sampling units to give each bush/branch
an equal weight. 
- Analyze the log(mean response) using a simple linear regression. This will give an estimate of the combined year-specific and sampling variation
around regression line (overall sd).
- Use the overall SD to estimate power and sample size requirements.

Here are the overall means for each year for each response:

```{r}
#| echo: false
#| warning: false
#| message: false
#| error: true

# get the mean values of 1 number per site per year
berry.weight$Mean.response <- berry.weight$Mean.weight
berry.weight$Response      <- "Berry weight"

stemd.mean1 <- plyr::ddply(stem.diam, c("STUDY_AREA_NAME","Year","BUSH"), plyr::summarize,
                                mean.stem=mean(Branch.Diameter..mm., na.rm=TRUE))
stemd.mean2 <- plyr::ddply(stemd.mean1, c("STUDY_AREA_NAME","Year"), plyr::summarize,
                                mean.stem=mean(mean.stem, na.rm=TRUE))
stemd.mean2$Mean.response <- stemd.mean2$mean.stem
stemd.mean2$Response      <- "Stem Diameter"

count.mean1 <- plyr::ddply(count.df, c("STUDY_AREA_NAME","Year","BUSH"), plyr::summarize,
                                mean.count=mean(Berry.Count, na.rm=TRUE))
count.mean2 <- plyr::ddply(count.mean1, c("STUDY_AREA_NAME","Year"), plyr::summarize,
                                mean.count=mean(mean.count, na.rm=TRUE))
count.mean2$Mean.response <- count.mean2$mean.count
count.mean2$Response      <- "Berry Count"

all.resp <- plyr::rbind.fill(berry.weight, stemd.mean2, count.mean2)
all.resp$Mean.weight    <- NULL
all.resp$Mean.weight.sd <- NULL
all.resp$mean.stem      <- NULL
all.resp$mean.count     <- NULL
all.resp

```

The above data needs to be checked if there are any suspicious values.  

We use the *lm()* function to fit linear regression over time on the log(scale) and obtain the combined year-specific effect (process error) 
plus sampling variation standard deviation (@tbl-resid-sd).

```{r}
#| echo: false
#| warning: false
#| message: false
#| error: true
#| tbl-cap: "Estimated residual (process + sampling) standard deviation"
#| label: tbl-resid-sd

# if any of the values are zero, add a small offset
all.resp <- plyr::ddply(all.resp, "Response", function(x){
     offset <- min(x$Mean.response[x$Mean.response>0]) *.5
     x$Mean.response <- x$Mean.response + offset
     x
})

# fit a regression line on the log(scale) and get the residual sd
residual.sd <- plyr::ddply(all.resp, "Response", function(x){
    fit <- lm(log(Mean.response) ~ Year, data=x)
    sd  <- summary(fit)$sigma
    data.frame(sd=sd)
})

ft <- flextable(residual.sd)
ft <- width(ft, j=1, width=2)
ft <- width(ft, j=2, width=2)
ft <- colformat_double(ft, j=2, digits=4)
ft <- set_header_labels(ft, values = list(sd="Process + sampling SD"))
 
ft
```

This is then used to estimate the power to detect various proportional changes over time (@fig-power).

```{r}
#| echo: false
#| warning: false
#| message: false
#| error: true
#| fig-cap: "Estimated power to detect proportional changes over time"
#| label: fig-power

# remove any missing values for resid.sd
residual.sd <- residual.sd[!is.na(residual.sd$sd),]

# estimate power at changes of 0 to .10/year with sample sizes of 5 to 20 years for each response
scenarios <- expand.grid(n.years=seq(5,20,1),
                         slope  =seq(0, .1, .02))
power.detect <- plyr::ddply(residual.sd, "Response", function(x, scenarios){
   
   power <- plyr::adply(scenarios,1, function(scenario,x){
      #browser()
      power <- slr.power.stroup(Trend=scenario$slope,
                                Xvalues=1:scenario$n.years,
                                Process.SD=x$sd,
                                Sampling.SD=0)
      power
   },x=x)
}, scenarios=scenarios)

ggplot(data=power.detect, aes(x=n.years, y=power.2s, color=as.factor(slope)))+
   ggtitle("Estimated power", subtitle="alpha=0.05")+
   geom_point()+
   geom_line()+
   facet_wrap(~Response, ncol=1)+
   ylab("Power")+xlab("Number of years in the study")+
   scale_color_discrete(name="Proportional\nyearly\nslope")+
   xlim(0,NA)+ylim(0,1)+
   geom_hline(yintercept=0.8)

```
 
The proportional yearly slope indicates the effect size of interest. For example, a value
of .02 would indicated a 2% change/year in the mean response.
 
In cases of high variability (e.g., in the berry count), the power is uniformly low 
to detect the yearly proportion change over time. 
In cases of low variability (e.g., in stem diameter) power is uniformly very high
to detect the yearly proportion change over time.



# Summary

Some caution is needed about the interpretation of the slope in 
short time series. 
Here most of the stems/bushes were measured for at least two years, 
so the above trend lines may represent nothing more than normal growth 
in stems as the bushes mature or senescence in berry production and berry weight as stem age. 
As an analogy, consider measuring the heights of children as they grow up. 
If the same cohort of children is repeated measured, you would expect to see a positive trend 
for many years simply as an artifact of the maturation. 
It may turn out that stem diameter is a surrogate for the stem age which, 
in turn could be a predictor for the berry count but at the moment 
there is insufficient information to know if this happens.
One way to deal with this problem is to NOT repeatedly sample the same 
bushes/stems over time. 
By taking a new sample each year (hopefully randomly selected), 
the variation in age in the sample should be similar over time 
(assuming that the soap berry plants are in “steady state”).
For this reason, this analysis protocol should be revisited after about 10 years 
to see if a more appropriate analysis may be more suitable when more 
data are collected and there are many plants that have been measured for many years. 
At the moment, there appears to be sufficient turnover in the three years that this issue may be moot.

At the moment, with short time series, the estimated power may not be fully reliable because 
of uncertainty in estimating the residual standard deviation, but is a start to understanding
how many years would be needed to detect proportion changes over time.



# References

Kuznetsova A, Brockhoff PB, Christensen RHB (2017). 
lmerTest Package: Tests in Linear Mixed Effects Models.
Journal of Statistical Software, 82, 1-26. 
doi:10.18637/jss.v082.i13
 
R Core Team (2023). R: A language and environment for statistical computing. 
R Foundation for Statistical Computing, Vienna, Austria. 
https://www.R-project.org/.


